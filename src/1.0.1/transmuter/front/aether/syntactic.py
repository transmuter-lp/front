# This file was automatically generated by Aether, the front-end
# generator for the Transmuter language processing infrastructure.

# Transmuter front-end, front-end libraries and utilities for the
# Transmuter language processing infrastructure
# Copyright (C) 2024  Natan Junges <natanajunges@gmail.com>
# Copyright (C) 2024, 2025  The Transmuter Project
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from transmuter.front.syntactic import (
    transmuter_selection,
    TransmuterNonterminalType,
    TransmuterParser,
    TransmuterInternalError,
)
from .common import Conditions
from .lexical import *


class Grammar(TransmuterNonterminalType):
    @staticmethod
    def start(conditions):
        return True

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(Production, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.call(Production, next_states[-1])
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class Production(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(ProductionHeader, next_states[-1])
        next_states[-1] = parser.call(ProductionBody, next_states[-1])
        return next_states[0]


class ProductionHeader(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(Identifier, next_states[-1])

        if Conditions.lexical in parser.lexer.conditions:
            try:  # begin optional
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(Condition, next_states[-1])
            except TransmuterInternalError:
                next_states.pop()
            else:
                next_states[-1] = next_states.pop()  # end optional

        try:  # begin optional
            next_states.append(next_states[-1])
            next_states[-1] = parser.call(
                ProductionSpecifiers, next_states[-1]
            )
        except TransmuterInternalError:
            next_states.pop()
        else:
            next_states[-1] = next_states.pop()  # end optional

        next_states[-1] = parser.call(Colon, next_states[-1])
        return next_states[0]


class ProductionBody(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(SelectionExpression, next_states[-1])
        next_states[-1] = parser.call(Semicolon, next_states[-1])
        return next_states[0]


class Condition(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(CommercialAt, next_states[-1])
        next_states[-1] = parser.call(DisjunctionCondition, next_states[-1])
        return next_states[0]


class ProductionSpecifiers(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(LeftParenthesis, next_states[-1])
        next_states[-1] = parser.call(ProductionSpecifierList, next_states[-1])
        next_states[-1] = parser.call(RightParenthesis, next_states[-1])
        return next_states[0]


class SelectionExpression(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(SequenceExpression, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                for _ in transmuter_selection:  # begin selection
                    try:  # begin option
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.call(
                            VerticalLine, next_states[-1]
                        )
                    except TransmuterInternalError:
                        next_states.pop()
                    else:
                        break  # end option

                    if Conditions.syntactic in parser.lexer.conditions:
                        next_states.append(next_states[-1])  # begin option

                        try:
                            next_states[-1] = parser.call(
                                Solidus, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                    raise TransmuterInternalError()

                next_states[-1] = next_states.pop()  # end selection
                next_states[-1] = parser.call(
                    SequenceExpression, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class DisjunctionCondition(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(ConjunctionCondition, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.call(
                    DoubleVerticalLine, next_states[-1]
                )
                next_states[-1] = parser.call(
                    ConjunctionCondition, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class ProductionSpecifierList(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(ProductionSpecifier, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.call(Comma, next_states[-1])
                next_states[-1] = parser.call(
                    ProductionSpecifier, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class SequenceExpression(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.call(
                        IterationExpression, next_states[-1]
                    )
                    next_states.append(next_states[-1])  # begin iteration

                    while True:
                        try:
                            next_states[-1] = parser.call(
                                IterationExpression, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                            break

                        next_states[-2] = next_states[-1]  # end iteration
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.call(
                        PrimaryExpression, next_states[-1]
                    )
                    next_states.append(next_states[-1])  # begin iteration

                    while True:
                        try:
                            next_states[-1] = parser.call(
                                PrimaryExpression, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                            break

                        next_states[-2] = next_states[-1]  # end iteration
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class ConjunctionCondition(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states[-1] = parser.call(NegationCondition, next_states[-1])
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.call(DoubleAmpersand, next_states[-1])
                next_states[-1] = parser.call(
                    NegationCondition, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        return next_states[0]


class ProductionSpecifier(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in transmuter_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])

                            for _ in transmuter_selection:  # begin selection
                                try:  # begin option
                                    next_states.append(next_states[-1])
                                    next_states[-1] = parser.call(
                                        PlusSign, next_states[-1]
                                    )
                                except TransmuterInternalError:
                                    next_states.pop()
                                else:
                                    break  # end option

                                try:  # begin option
                                    next_states.append(next_states[-1])
                                    next_states[-1] = parser.call(
                                        HyphenMinus, next_states[-1]
                                    )
                                except TransmuterInternalError:
                                    next_states.pop()
                                else:
                                    break  # end option

                                raise TransmuterInternalError()

                            next_states[-1] = (
                                next_states.pop()
                            )  # end selection
                            next_states[-1] = parser.call(
                                Identifier, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                Ignore, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        raise TransmuterInternalError()

                    next_states[-1] = next_states.pop()  # end selection
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.call(Start, next_states[-1])
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection

        try:  # begin optional
            next_states.append(next_states[-1])
            next_states[-1] = parser.call(Condition, next_states[-1])
        except TransmuterInternalError:
            next_states.pop()
        else:
            next_states[-1] = next_states.pop()  # end optional

        return next_states[0]


class IterationExpression(TransmuterNonterminalType):
    @staticmethod
    def first(conditions):
        first = set()

        if Conditions.lexical in conditions:
            first.add(PrimaryExpression)

        return first

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.call(
                        PrimaryExpression, next_states[-1], cls
                    )

                    try:  # begin optional
                        next_states.append(next_states[-1])

                        for _ in transmuter_selection:  # begin selection
                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.call(
                                    Asterisk, next_states[-1]
                                )
                            except TransmuterInternalError:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.call(
                                    PlusSign, next_states[-1]
                                )
                            except TransmuterInternalError:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.call(
                                    QuestionMark, next_states[-1]
                                )
                            except TransmuterInternalError:
                                next_states.pop()
                            else:
                                break  # end option

                            try:  # begin option
                                next_states.append(next_states[-1])
                                next_states[-1] = parser.call(
                                    ExpressionRange, next_states[-1]
                                )
                            except TransmuterInternalError:
                                next_states.pop()
                            else:
                                break  # end option

                            raise TransmuterInternalError()

                        next_states[-1] = next_states.pop()  # end selection
                    except TransmuterInternalError:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in transmuter_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                LeftCurlyBracket, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                LeftCurlyBracketSolidus, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        raise TransmuterInternalError()

                    next_states[-1] = next_states.pop()  # end selection
                    next_states[-1] = parser.call(
                        SelectionExpression, next_states[-1]
                    )
                    next_states[-1] = parser.call(
                        RightCurlyBracket, next_states[-1]
                    )
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class PrimaryExpression(TransmuterNonterminalType):
    @staticmethod
    def first(conditions):
        first = set()

        if Conditions.syntactic in conditions:
            first.add(IterationExpression)

        return first

    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            if Conditions.lexical in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in transmuter_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                OrdChar, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                QuotedChar, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                FullStop, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                BracketExpression, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        raise TransmuterInternalError()

                    next_states[-1] = next_states.pop()  # end selection
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    next_states[-1] = parser.call(Identifier, next_states[-1])

                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.call(
                            Condition, next_states[-1]
                        )
                    except TransmuterInternalError:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(LeftParenthesis, next_states[-1])
                next_states[-1] = parser.call(
                    SelectionExpression, next_states[-1]
                )
                next_states[-1] = parser.call(
                    RightParenthesis, next_states[-1]
                )

                if Conditions.syntactic in parser.lexer.conditions:
                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.call(
                            Condition, next_states[-1]
                        )
                    except TransmuterInternalError:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
            except TransmuterInternalError:
                next_states.pop()
            else:
                break  # end option

            if Conditions.syntactic in parser.lexer.conditions:
                next_states.append(next_states[-1])  # begin option

                try:
                    for _ in transmuter_selection:  # begin selection
                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                OptionalExpression, next_states[-1]
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        try:  # begin option
                            next_states.append(next_states[-1])
                            next_states[-1] = parser.call(
                                IterationExpression, next_states[-1], cls
                            )
                        except TransmuterInternalError:
                            next_states.pop()
                        else:
                            break  # end option

                        raise TransmuterInternalError()

                    next_states[-1] = next_states.pop()  # end selection

                    try:  # begin optional
                        next_states.append(next_states[-1])
                        next_states[-1] = parser.call(
                            Condition, next_states[-1]
                        )
                    except TransmuterInternalError:
                        next_states.pop()
                    else:
                        next_states[-1] = next_states.pop()  # end optional
                except TransmuterInternalError:
                    next_states.pop()
                else:
                    break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class NegationCondition(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]
        next_states.append(next_states[-1])  # begin iteration

        while True:
            try:
                next_states[-1] = parser.call(ExclamationMark, next_states[-1])
            except TransmuterInternalError:
                next_states.pop()
                break

            next_states[-2] = next_states[-1]  # end iteration

        next_states[-1] = parser.call(PrimitiveCondition, next_states[-1])
        return next_states[0]


class OptionalExpression(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(
                    LeftSquareBracket, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
            else:
                break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(
                    LeftSquareBracketSolidus, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
            else:
                break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection
        next_states[-1] = parser.call(SelectionExpression, next_states[-1])
        next_states[-1] = parser.call(RightSquareBracket, next_states[-1])
        return next_states[0]


class PrimitiveCondition(TransmuterNonterminalType):
    @classmethod
    def descend(cls, parser, current_state):
        next_states = [{current_state}]

        for _ in transmuter_selection:  # begin selection
            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(Identifier, next_states[-1])
            except TransmuterInternalError:
                next_states.pop()
            else:
                break  # end option

            try:  # begin option
                next_states.append(next_states[-1])
                next_states[-1] = parser.call(LeftParenthesis, next_states[-1])
                next_states[-1] = parser.call(
                    DisjunctionCondition, next_states[-1]
                )
                next_states[-1] = parser.call(
                    RightParenthesis, next_states[-1]
                )
            except TransmuterInternalError:
                next_states.pop()
            else:
                break  # end option

            raise TransmuterInternalError()

        next_states[-1] = next_states.pop()  # end selection
        return next_states[0]


class Parser(TransmuterParser):
    NONTERMINAL_TYPES = [
        Grammar,
        Production,
        ProductionHeader,
        ProductionBody,
        Condition,
        ProductionSpecifiers,
        SelectionExpression,
        DisjunctionCondition,
        ProductionSpecifierList,
        SequenceExpression,
        ConjunctionCondition,
        ProductionSpecifier,
        IterationExpression,
        PrimaryExpression,
        NegationCondition,
        OptionalExpression,
        PrimitiveCondition,
    ]
